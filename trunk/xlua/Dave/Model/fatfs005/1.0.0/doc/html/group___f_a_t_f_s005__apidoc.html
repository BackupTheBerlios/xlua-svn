<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>

<title>API Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">API Documentation</div>  </div>
<div class="ingroups"><a class="el" href="group___f_a_t_f_s005_app.html">FileSystem_DeviceAbstraction_RTOS_FATFS005 App</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td class="memItemLeft" align="right" valign="top">DSTATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_a_t_f_s005__apidoc.html#gad478bd74a7c9c7e3e2efc96b150444b2">disk_initialize</a> (BYTE Drive)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes a physical drive and put it ready to read/write. Application program should not call this function, or FAT structure on the volume can be collapted. To re-initialize the file system, use f_mount function.This function is called on volume mount process in the FatFs module to manage the media change.  <a href="#gad478bd74a7c9c7e3e2efc96b150444b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DSTATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_a_t_f_s005__apidoc.html#gaba1e2e1e00fb3ee96fcbe368322308eb">disk_status</a> (BYTE Drive)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The disk_status function returns the current disk status.  <a href="#gaba1e2e1e00fb3ee96fcbe368322308eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_a_t_f_s005__apidoc.html#gad5fb230f562282e193d1e2fb2f2fb6b8">disk_read</a> (BYTE Drive, BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The disk_read function reads sector(s) from the disk drive. Note that the specified memory address to store read data is not that always aligned to word boundary. If the hardware does not support misaligned data transfer, it must be solved in this function.  <a href="#gad5fb230f562282e193d1e2fb2f2fb6b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_a_t_f_s005__apidoc.html#ga485864735b5a0f26c776826cf2c4a252">disk_write</a> (BYTE Drive, const BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The disk_write writes sector(s) to the disk.Note that the specified memory address from where to write data is not that always aligned to word boundary. If the hardware does not support misaligned data transfer, it must be solved in this function.This function is not required in read only configuration.  <a href="#ga485864735b5a0f26c776826cf2c4a252"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_a_t_f_s005__apidoc.html#ga622d5a92ecdbf9eafffdef70febde763">disk_ioctl</a> (BYTE Drive, BYTE Command, void *Buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The disk_ioctl function controls device specified features and miscellaneous functions other than disk read/write. The FatFs module uses only device independent commands described below. Any device dependent function is not used.  <a href="#ga622d5a92ecdbf9eafffdef70febde763"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DWORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_a_t_f_s005__apidoc.html#gaf58b536abfd30f77213f4ecaf2ac52f5">get_fattime</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The get_fattime function gets current time.The get_fattime function must return any valid time even if the system does not support a real time clock. If a zero is returned, the file will not have a valid time. This fucntion is not required in read only configuration.  <a href="#gaf58b536abfd30f77213f4ecaf2ac52f5"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad478bd74a7c9c7e3e2efc96b150444b2"></a><!-- doxytag: member="FATFS005.h::disk_initialize" ref="gad478bd74a7c9c7e3e2efc96b150444b2" args="(BYTE Drive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DSTATUS <a class="el" href="group___f_a_t_f_s005__apidoc.html#gad478bd74a7c9c7e3e2efc96b150444b2">disk_initialize</a> </td>
          <td>(</td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>Drive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function initializes a physical drive and put it ready to read/write. Application program should not call this function, or FAT structure on the volume can be collapted. To re-initialize the file system, use f_mount function.This function is called on volume mount process in the FatFs module to manage the media change. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Drive</td><td>Specifies the physical drive number to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>DSTATUS<br/>
 Returns Disk status as the result.<br/>
 Refer disk_status function for details of status flags.<br/>
 <b>Reentrant: Yes </b><br/>
 <b>Sync/Async: Synchronous</b> <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;DAVE3.h&gt;</span>
 <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
 {
   DSTATUS DStatus;
   <span class="comment">// DAVE Initialization.</span>
   DAVE_Init();
   <span class="comment">// SDMMC drive number will be at &#39;0&#39; drive </span>
   DStatus =  <a class="code" href="group___f_a_t_f_s005__apidoc.html#gad478bd74a7c9c7e3e2efc96b150444b2" title="This function initializes a physical drive and put it ready to read/write. Application program should...">disk_initialize</a>(0);
   <span class="keywordflow">if</span> (DStatus == (STA_NODISK | STA_NOINIT))
   {
     <span class="comment">//No card Present;</span>
   }
   <span class="keywordflow">if</span> (DStatus == STA_NOINIT)
   {
    <span class="comment">//Card Present but not initialized.</span>
   }
   <span class="keywordflow">if</span> (DStatus == STA_PROTECT)
   {
     <span class="comment">//Card is Write Protected .</span>
   } 
   <span class="keywordflow">return</span> 0;
 }
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="ga622d5a92ecdbf9eafffdef70febde763"></a><!-- doxytag: member="FATFS005.h::disk_ioctl" ref="ga622d5a92ecdbf9eafffdef70febde763" args="(BYTE Drive, BYTE Command, void *Buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DRESULT <a class="el" href="group___f_a_t_f_s005__apidoc.html#ga622d5a92ecdbf9eafffdef70febde763">disk_ioctl</a> </td>
          <td>(</td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>Drive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The disk_ioctl function controls device specified features and miscellaneous functions other than disk read/write. The FatFs module uses only device independent commands described below. Any device dependent function is not used. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Drive</td><td>Specifies the drive number (0-9). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Command</td><td>Specifies the command code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the parameter buffer depends on the command code. When it is not used, specify a NULL pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>DRESULT <br/>
 RES_OK The function succeeded.<br/>
 RES_ERROR Any error occurred.<br/>
 RES_PARERR Invalid command code.<br/>
 RES_NOTRDY The disk drive has not been initialized.<br/>
 <b>Reentrant: Yes </b><br/>
 <b>Sync/Async: Synchronous</b> <br/>
</dd></dl>
<p><b>Generic command (defined for FatFs) </b><br/>
 </p>
<p>CTRL_SYNC: Flush disk cache (for write functions) <br/>
 GET_SECTOR_COUNT: Get media size (for only f_mkfs()) <br/>
 GET_SECTOR_SIZE: Get sector size (for multiple sector size (_MAX_SS &gt;= 1024)) <br/>
 GET_BLOCK_SIZE: Get erase block size (for only f_mkfs()) <br/>
 CTRL_ERASE_SECTOR: Force erased a block of sectors (for only _USE_ERASE) <br/>
  <br/>
 <b> Generic command </b> <br/>
 </p>
<p>CTRL_EJECT: Eject media <br/>
 <b> MMC/SDC specific ioctl commands </b> <br/>
 </p>
<p>MMC_GET_TYPE: Get card type <br/>
 MMC_GET_CSD: Get CSD <br/>
 MMC_GET_CID: Get CID <br/>
 MMC_GET_OCR: Get OCR <br/>
 MMC_GET_SDSTAT: Get SD status <br/>
   </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;DAVE3.h&gt;</span>
 <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
 {
   DRESULT Result;
   uint32_t Buffer;
   <span class="comment">// Get Sector Count</span>
   Result = <a class="code" href="group___f_a_t_f_s005__apidoc.html#ga622d5a92ecdbf9eafffdef70febde763" title="The disk_ioctl function controls device specified features and miscellaneous functions other than dis...">disk_ioctl</a>(0,GET_SECTOR_COUNT,(<span class="keywordtype">void</span> *)&amp;Buffer);
   <span class="keywordflow">if</span> (Result == RES_OK)
   {
     <span class="comment">// Get Card Type</span>
     Result = <a class="code" href="group___f_a_t_f_s005__apidoc.html#ga622d5a92ecdbf9eafffdef70febde763" title="The disk_ioctl function controls device specified features and miscellaneous functions other than dis...">disk_ioctl</a>( 0,MMC_GET_TYPE,(<span class="keywordtype">void</span> *)&amp;Buffer);
     <span class="keywordflow">if</span> (Result == RES_OK )
     {
       <span class="keywordflow">if</span>( Buffer &amp; SDMMC003_SD_STANDARD_CAPACITY_V2)
       {
         <span class="comment">// Standard Capacity Card version2</span>
       }
       <span class="keywordflow">if</span>( Buffer &amp; SDMMC003_SD_STANDARD_CAPACITY_V1x)
       {
         <span class="comment">// Standard Capacity Card version1.</span>
       } 
       <span class="keywordflow">if</span>( Buffer &amp; SDMMC003_SD_HIGH_CAPACITY)
       {
         <span class="comment">// High Capacity Card.</span>
       }
     }
   }
   <span class="comment">// Eject card //</span>
   Result = <a class="code" href="group___f_a_t_f_s005__apidoc.html#ga622d5a92ecdbf9eafffdef70febde763" title="The disk_ioctl function controls device specified features and miscellaneous functions other than dis...">disk_ioctl</a>(0,CTRL_EJECT,NULL);
   <span class="keywordflow">return</span> 0;
 }
</pre></div> 
</div>
</div>
<a class="anchor" id="gad5fb230f562282e193d1e2fb2f2fb6b8"></a><!-- doxytag: member="FATFS005.h::disk_read" ref="gad5fb230f562282e193d1e2fb2f2fb6b8" args="(BYTE Drive, BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DRESULT <a class="el" href="group___f_a_t_f_s005__apidoc.html#gad5fb230f562282e193d1e2fb2f2fb6b8">disk_read</a> </td>
          <td>(</td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>Drive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>SectorNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>SectorCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The disk_read function reads sector(s) from the disk drive. Note that the specified memory address to store read data is not that always aligned to word boundary. If the hardware does not support misaligned data transfer, it must be solved in this function. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Drive</td><td>Physical drive number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the byte array to store the read data. The buffer size of number of bytes to be read, sector size * sector count, is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SectorNumber</td><td>Specifies the start sector number in logical block address (LBA). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SectorCount</td><td>Specifies number of sectors to read. The value can be 1 to 128. Generally, a multiple sector transfer request must not be split into single sector transactions to the device, or you may not get good read performance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>DRESULT <br/>
 RES_OK The function succeeded.<br/>
 RES_ERROR Any hard error occurred during the read operation and could not recover it.<br/>
 RES_PARERR Invalid parameter<br/>
 RES_NOTRDY The disk drive has not been initialized.<br/>
 <b>Reentrant: Yes </b><br/>
 <b>Sync/Async: Synchronous</b> <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;DAVE3.h&gt;</span>
 <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
 {
   uint32_t Counter = 0;
   uint32_t Count = 0;
   DRESULT DResult;
    <span class="comment">// NOTE: This buffer has to be aligned to 4-byte boundary !!!!!!!</span>
   uint32_t ReadData[256] = {0};
   uint32_t WriteData[256] = {0};
   <span class="comment">// DAVE Initialization.</span>
   DAVE_Init();
   <span class="comment">// Write some data to be written on the card </span>
   <span class="keywordflow">for</span>(Counter=0;Counter&lt;256;Counter++)
   {
     WriteData[Counter] = Counter * 10;
   }
   <span class="comment">// Write functionality </span>
   DResult =  <a class="code" href="group___f_a_t_f_s005__apidoc.html#ga485864735b5a0f26c776826cf2c4a252" title="The disk_write writes sector(s) to the disk.Note that the specified memory address from where to writ...">disk_write</a>(0,(uint8_t*)WriteData,200, 2);
   <span class="keywordflow">if</span>(DResult == RES_OK)
   {
     <span class="comment">// Read functionality </span>
     DResult =  <a class="code" href="group___f_a_t_f_s005__apidoc.html#gad5fb230f562282e193d1e2fb2f2fb6b8" title="The disk_read function reads sector(s) from the disk drive. Note that the specified memory address to...">disk_read</a>(0, (uint8_t*)ReadData, 200, 2);
     <span class="comment">// Write and Read data validation</span>
     <span class="keywordflow">for</span>( Count=0; Count&lt;256; Count++)
     {
       <span class="keywordflow">if</span>( ReadData[Count] != WriteData[Count])
       {
         <span class="comment">// Read and Write Data doesn&#39;t match.</span>
       }
     }
   }
   <span class="keywordflow">return</span> 0;
 }
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="gaba1e2e1e00fb3ee96fcbe368322308eb"></a><!-- doxytag: member="FATFS005.h::disk_status" ref="gaba1e2e1e00fb3ee96fcbe368322308eb" args="(BYTE Drive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DSTATUS <a class="el" href="group___f_a_t_f_s005__apidoc.html#gaba1e2e1e00fb3ee96fcbe368322308eb">disk_status</a> </td>
          <td>(</td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>Drive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The disk_status function returns the current disk status. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Drive</td><td>Specifies the physical drive number to be confirmed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>DSTATUS<br/>
 Returns disk status as the result.<br/>
 <b>STA_NOINIT:</b> Indicates that the disk drive has not been initialized. This flag is set on: system reset, disk removal and disk_initialize function failed, and cleared on: disk_initialize function succeeded. <br/>
 <b>STA_NODISK:</b>Indicates that no medium in the drive. This is always cleared on fixed disk drive.<br/>
 <b>STA_PROTECTED:</b>Indicates that the medium is write protected. This is always cleared on the drive that does not support write protect notch. Not valid when STA_NODISK is set. <br/>
 <b>Reentrant: Yes </b><br/>
 <b>Sync/Async: Synchronous</b> <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;DAVE3.h&gt;</span>
 <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
 {
   DSTATUS DStatus;
   <span class="comment">// DAVE Initialization.</span>
   DAVE_Init();
   <span class="comment">// SDMMC drive number will be at &#39;0&#39; drive  </span>
   DStatus =  <a class="code" href="group___f_a_t_f_s005__apidoc.html#gaba1e2e1e00fb3ee96fcbe368322308eb" title="The disk_status function returns the current disk status.">disk_status</a>(0);
   <span class="keywordflow">if</span> (DStatus == (STA_NODISK | STA_NOINIT))
   {
     <span class="comment">//No card Present;</span>
   }
   <span class="keywordflow">if</span> (DStatus == STA_NOINIT)
   {
     <span class="comment">//Card Present but not initialized.</span>
   }
   <span class="keywordflow">if</span> (DStatus == STA_PROTECT)
   {
     <span class="comment">//Card is Write Protected .</span>
   } 
   <span class="keywordflow">return</span> 0;
 }
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="ga485864735b5a0f26c776826cf2c4a252"></a><!-- doxytag: member="FATFS005.h::disk_write" ref="ga485864735b5a0f26c776826cf2c4a252" args="(BYTE Drive, const BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DRESULT <a class="el" href="group___f_a_t_f_s005__apidoc.html#ga485864735b5a0f26c776826cf2c4a252">disk_write</a> </td>
          <td>(</td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>Drive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>SectorNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>SectorCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The disk_write writes sector(s) to the disk.Note that the specified memory address from where to write data is not that always aligned to word boundary. If the hardware does not support misaligned data transfer, it must be solved in this function.This function is not required in read only configuration. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Drive</td><td>Specifies the physical drive number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the byte array to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SectorNumber</td><td>Specifies the start sector number in logical block address (LBA). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SectorCount</td><td>Specifies the number of sectors to write. The value can be 1 to 128. Generally, a multiple sector transfer request must not be split into single sector transactions to the device, or you will never get good write performance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RES_OK The function succeeded.<br/>
 RES_ERROR Any hard error occured during the write operation and could not recover it.<br/>
 RES_PARERR Invalid parameter<br/>
 RES_NOTRDY The disk drive has not been initialized.<br/>
 RES_WRPRT The medium is write protected.<br/>
 <b>Reentrant: Yes </b><br/>
 <b>Sync/Async: Synchronous</b> <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;DAVE3.h&gt;</span>
 <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
 {
   DRESULT DResult;
   uint32_t Counter = 0;
   uint32_t Count = 0;
    <span class="comment">// NOTE: This buffer has to be aligned to 4-byte boundary !!!!!!!</span>
   uint32_t ReadData[256] = {0};
   uint32_t WriteData[256] = {0};
   <span class="comment">// DAVE Initialization.</span>
   DAVE_Init();
   <span class="keywordflow">for</span>(Counter=0;Counter&lt;256;Counter++)
   {
     WriteData[Counter] = Counter * 10;
   }
   <span class="comment">// Write functionality </span>
   DResult =  <a class="code" href="group___f_a_t_f_s005__apidoc.html#ga485864735b5a0f26c776826cf2c4a252" title="The disk_write writes sector(s) to the disk.Note that the specified memory address from where to writ...">disk_write</a>(0,(uint8_t*)WriteData,200, 2);
   <span class="keywordflow">if</span>(DResult == RES_OK)
   {
     <span class="comment">// Read data from card to verify the data written. </span>
     DResult =  <a class="code" href="group___f_a_t_f_s005__apidoc.html#gad5fb230f562282e193d1e2fb2f2fb6b8" title="The disk_read function reads sector(s) from the disk drive. Note that the specified memory address to...">disk_read</a>(0, (uint8_t*)ReadData, 200, 2);
     <span class="keywordflow">for</span>( Count=0; Count&lt;256; Count++)
     {
       <span class="keywordflow">if</span>( ReadData[Count] != WriteData[Count])
       {
         <span class="comment">// Read and Write Data doesn&#39;t match.</span>
       }
     }
   }
   <span class="keywordflow">return</span> 0;
 }
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf58b536abfd30f77213f4ecaf2ac52f5"></a><!-- doxytag: member="FATFS005.h::get_fattime" ref="gaf58b536abfd30f77213f4ecaf2ac52f5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DWORD <a class="el" href="group___f_a_t_f_s005__apidoc.html#gaf58b536abfd30f77213f4ecaf2ac52f5">get_fattime</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The get_fattime function gets current time.The get_fattime function must return any valid time even if the system does not support a real time clock. If a zero is returned, the file will not have a valid time. This fucntion is not required in read only configuration. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current time is returned with packed into a DWORD value. The bit field is as follows:<br/>
 bit31:25: Year from 1980 (0..127)<br/>
 bit24:21: Month (1..12)<br/>
 bit20:16: Day in month(1..31)<br/>
 bit15:11: Hour (0..23)<br/>
 bit10:5: Minute (0..59)<br/>
 bit4:0: Second / 2 (0..29)<br/>
 <b>Reentrant: Yes </b><br/>
 <b>Sync/Async: Synchronous</b> <div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;DAVE3.h&gt;</span>
 <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
 {
   uint32_t Time;
   Time = <a class="code" href="group___f_a_t_f_s005__apidoc.html#gaf58b536abfd30f77213f4ecaf2ac52f5" title="The get_fattime function gets current time.The get_fattime function must return any valid time even i...">get_fattime</a>();
   <span class="keywordflow">return</span> 0;
 }
</pre></div> </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
<b>v1.0.0</b> Generated on Thu Sep 13 2012 16:11:19 for .&#160;<img class="footer" src="../image002.gif"/></small></address>
</body>
</html>
