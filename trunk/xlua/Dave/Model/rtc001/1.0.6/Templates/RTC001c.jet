<%@ jet package="CodeGenerator" class="RTC001Template" 
imports="com.ifx.davex.appjetinteract.App2JetInterface" %>
<% App2JetInterface app = (App2JetInterface) argument; %>

/*CODE_BLOCK_BEGIN[RTC001.c]*/

 /*******************************************************************************
 Copyright (c) 2011, Infineon Technologies AG                                 **
 All rights reserved.                                                         **
                                                                              **
 Redistribution and use in source and binary forms, with or without           **
 modification,are permitted provided that the following conditions are met:   **
                                                                              **
 *Redistributions of source code must retain the above copyright notice,      **
 this list of conditions and the following disclaimer.                        **
 *Redistributions in binary form must reproduce the above copyright notice,   **
 this list of conditions and the following disclaimer in the documentation    **
 and/or other materials provided with the distribution.                       **
 *Neither the name of the copyright holders nor the names of its contributors **
 may be used to endorse or promote products derived from this software without**
 specific prior written permission.                                           **
                                                                              **
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  **
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **
 ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **
 LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **
 SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **
 CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **
 POSSIBILITY OF SUCH DAMAGE.                                                  **
                                                                              **
 To improve the quality of the software, users are encouraged to share        **
 modifications, enhancements or bug fixes with Infineon Technologies AG       **
 dave@infineon.com).                                                          **
                                                                              **
********************************************************************************
**                                                                            **
**                                                                            **
** PLATFORM : Infineon XMC4000 Series                                         **
**                                                                            **
** COMPILER : Compiler Independent                                            **
**                                                                            **
** AUTHOR   : App Developer                                                   **
**                                                                            **
** MAY BE CHANGED BY USER [yes/no]: Yes                                       **
**                                                                            **
** MODIFICATION DATE : Jan 10, 2012                                           **
**                                                                            **
*******************************************************************************/
/*******************************************************************************
**                      Author(s) Identity                                    **
********************************************************************************
**                                                                            **
** Initials     Name                                                          **
** ---------------------------------------------------------------------------**
** RP        App Developer                                                    **
**                                                                            **
*******************************************************************************/
/**
 * @file RTC001.c
 *
 * @brief  Real Time Clock App Implementation.
 *
 */
/*******************************************************************************
 ** INCLUDE FILES                                                             **
 ******************************************************************************/
<% String AppBaseuri = "app/RTC001/0";%> 
<% String UserFunc = null;%>
/* Inclusion of header file */
#include <DAVE3.h>
 
/*******************************************************************************
**                      Private Macro Definitions                             **
*******************************************************************************/

/* Update completion */
#define RTC001_UPDATE_COMPLETED	1U

/*******************************************************************************
**                      Private Type Definitions                              **
*******************************************************************************/
<% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>
/** 
 * Note: This part of the code will be generated if Software Timer is
 *       enabled. This part is not reviewed and tested
 **/
/**
 * This enumerates the timer state.
 */
typedef enum RTC001_TimerStateType{
/**
 * The timer is in running state
 */
  TIMER_STATE_RUNNING,
/**
  * The timer is stopped
 */
  TIMER_STATE_STOPPED 
}RTC001_TimerStateType;
<% } else {
 }%>

/*******************************************************************************
**                 Private Function Declarations:
*******************************************************************************/
 <% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>		
 /** 
  * Note: This part of the code will be generated if Software Timer is
  *       enabled. This part is not reviewed and tested
  **/
/*
 * This function is called to insert a timer into the timer list.  
 *        
 * @param[in]  Index Timer ID
 * @return     none
 *      
 * <b>Reentrant: NO </b><BR>
 *
 */
static void  RTC001_lInsertTimerList (uint32_t Index);


/*
 * This function is called to remove a timer from the timer list. 
 *              
 * @param[in]  Index Timer ID
 * @return     none
 *      
 * <b>Reentrant: NO </b><BR>
 *
 */
static void  RTC001_lRemoveTimerList(uint32_t Index);

/*
 * Handler function called from Seconds event handler. 
 *              
 * @return     void 
 *      
 * <b>Reentrant: NO </b><BR>
 *
 */
static void  RTC001_lTimerHandler (void);
 
/*
 * Time event handler 
 *              
 * @return     void 
 *      
 * <b>Reentrant: NO </b><BR>
 *
 */
static void RTC001_SecondsEvent_Handler(uint32_t CbArg);
<% } else {
 }%>

/*
 * Function to check whether the date is valid
 *              
 * @return     void 
 *      
 * <b>Reentrant: NO </b><BR>
 *
 */
static uint32_t RTC001_ldatevalid(uint16_t m, uint16_t d, uint16_t y);


/*
 * Function to calculate day of the week
 *              
 * @return     void 
 *      
 * <b>Reentrant: NO </b><BR>
 *
 */
static uint32_t RTC001_lweekday(uint16_t m, uint16_t d, uint16_t y);

/*
 * Function to initialize
 *
 * @return     void
 *
 * <b>Reentrant: NO </b><BR>
 *
 */
static void  RTC001_lInit(const RTC001_HandleType* Handle);

/*******************************************************************************
**                      Global Constant Definitions                           **
*******************************************************************************/



/*******************************************************************************
**                      Global Variable Definitions                           **
*******************************************************************************/
<% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>
/** 
 * Note: This part of the code will be generated if Software Timer is
 *       enabled. This part is not reviewed and tested
 **/
/** Table which save timer control block. */
RTC001_TimerObject    RTC001_TimerTbl[RTC001_CFG_MAX_TMR] = {{0}};

/** The header of the TimerCtrl list.      */
RTC001_TimerObject*  RTC001_TimerList = 0; 

/**   Timer ID Tracker  */
uint32_t       RTC001_TimerTracker = 0;
<% } else {
 }%>

/*******************************************************************************
**                      Private Constant Definitions                          **
*******************************************************************************/



/*******************************************************************************
**                 Function like macro definitions                            **
*******************************************************************************/



/*******************************************************************************
**                      Private Function Definitions                          **
*******************************************************************************/
 
 <% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>					
 /** 
  * Note: This part of the code will be generated if Software Timer is
  *       enabled. This part is not reviewed and tested
  **/
/*
 * This function is called to insert a timer into the timer list.
 */
static void  RTC001_lInsertTimerList (uint32_t Index)
{
  /* <<<DD_RTC001_PRIV_API_1>>> */
  RTC001_TimerObject* TmrObjPtr;
  int32_t DeltaTicks;
  uint32_t TempTmrCnt;
   /* Get timer time */
  TempTmrCnt = RTC001_TimerTbl[Index].TimerCount;
  /* Check if timer count is zero */
  /* <<<DD_RTC001_PRIV _API_1>>> */
  do
  {
    if(TempTmrCnt == 0)                  
    {
      break;                                          
    }
    /* Check if Timer list is NULL */
    if(RTC001_TimerList == NULL)                
    {
      /* Set this as first Timer */
        RTC001_TimerList = &RTC001_TimerTbl[Index];       
    }
    /* IF Not, find the correct place ,and insert the specified timer */
    else                  
    {								    
      TmrObjPtr = RTC001_TimerList; 
      /* Get timer tick */
      DeltaTicks = (int32_t)TempTmrCnt;           
      /* Find correct place for inserting the timer */
      while(TmrObjPtr != NULL)
      {				    
        /* Get timer Count Difference  */
        DeltaTicks -= (int32_t)TmrObjPtr->TimerCount;
        /* Is delta ticks<0? */
        if(DeltaTicks < 0)            
        {	
          /*  Check If head item */
          if(TmrObjPtr->TimerPrev!= NULL)
          {	
            /* If Insert to list */
            TmrObjPtr->TimerPrev->TimerNext = &RTC001_TimerTbl[Index]; 
            RTC001_TimerTbl[Index].TimerPrev = TmrObjPtr->TimerPrev;
            RTC001_TimerTbl[Index].TimerNext = TmrObjPtr;
            TmrObjPtr->TimerPrev = &RTC001_TimerTbl[Index];
          }
          else                    	
          { 
            /* Set Timer as first item */
            RTC001_TimerTbl[Index].TimerNext = RTC001_TimerList;
            RTC001_TimerList->TimerPrev = &RTC001_TimerTbl[Index];
            RTC001_TimerList = &RTC001_TimerTbl[Index];
          }
          RTC001_TimerTbl[Index].TimerCount = RTC001_TimerTbl[Index].TimerNext->TimerCount + (uint32_t)DeltaTicks;  
          RTC001_TimerTbl[Index].TimerNext->TimerCount  -= RTC001_TimerTbl[Index].TimerCount; 
          break;	
        }
        /* Is last item in list? */									
        else 
        {	
          if((DeltaTicks >= 0) && (TmrObjPtr->TimerNext == NULL))
          {
            /* Yes,insert into */
            RTC001_TimerTbl[Index].TimerPrev = TmrObjPtr;
            TmrObjPtr->TimerNext = &RTC001_TimerTbl[Index];	
            RTC001_TimerTbl[Index].TimerCount = (uint32_t)DeltaTicks;
            break;
          }
        }
        /* Get the next item in timer list    */	
        TmrObjPtr = TmrObjPtr->TimerNext;      
      }
    }
  }while(0);
}

/*
 * This function is called to remove a timer from the timer list. 
 */
static void  RTC001_lRemoveTimerList(uint32_t Index)
{
  /* <<<DD_RTC001_PRIV_API_2>>> */
  RTC001_TimerObject* TmrObjPtr;
  TmrObjPtr = &RTC001_TimerTbl[Index];
  /* Check whether only one timer available */
  /* <<<DD_RTC001_PRIV _API_2>>> */
  if((TmrObjPtr->TimerPrev == NULL) && (TmrObjPtr->TimerNext == NULL))
  {		
    /* set timer list as NULL */ 
    RTC001_TimerList = NULL;                 	
  }
   /* Check if the first item in timer list   */
  else if(TmrObjPtr->TimerPrev == NULL)     
  {   
    /* Remove timer from list,and reset timer list */
    RTC001_TimerList  = TmrObjPtr->TimerNext;
    RTC001_TimerList->TimerPrev = NULL;
    TmrObjPtr->TimerNext->TimerCount += TmrObjPtr->TimerCount;
    TmrObjPtr->TimerNext    = NULL;  
  }
  /* Check if the last item in timer list   */
  else if(TmrObjPtr->TimerNext == NULL)      
  {
    /* Remove timer from list */
    TmrObjPtr->TimerPrev->TimerNext = NULL;	
    TmrObjPtr->TimerPrev = NULL;
  }
  else                                /*  remove timer from list         */
  {
    /*  Remove timer from list */
    TmrObjPtr->TimerPrev->TimerNext  =  TmrObjPtr->TimerNext;
    TmrObjPtr->TimerNext->TimerPrev  =  TmrObjPtr->TimerPrev;
    TmrObjPtr->TimerNext->TimerCount  += TmrObjPtr->TimerCount;
    TmrObjPtr->TimerNext = NULL;
    TmrObjPtr->TimerPrev = NULL;
  }
}

/*
 * Handler function  called from RTC event handler. 
 */
static void  RTC001_lTimerHandler (void)
{
  /* <<<DD_RTC001_PRIV_API_3>>> */
  RTC001_TimerObject* TmrObjPtr;
   /* Get first item of timer list       */
  TmrObjPtr = RTC001_TimerList;         
  /* <<<DD_RTC001_PRIV _API_3>>> */  
  while((TmrObjPtr != NULL) && (TmrObjPtr->TimerCount == 0) )
  {	
    /* Check whether timer is a one shot timer */
    if(TmrObjPtr->TimerType == RTC001_ONE_SHOT)
    {
      /* Yes,remove this timer from timer list */
      RTC001_lRemoveTimerList(TmrObjPtr->TimerID);
      /* Set timer status as TIMER_STATE_STOPPED */
      TmrObjPtr->TimerState = TIMER_STATE_STOPPED;
      /* Call timer callback function */
      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);
    }
    /* Check whether timer is RTC001_PERIODIC */
    else if(TmrObjPtr->TimerType == RTC001_PERIODIC)
    {
      /* Yes,remove this timer from timer list */
      RTC001_lRemoveTimerList(TmrObjPtr->TimerID);
      /* Reset timer tick             */
      TmrObjPtr->TimerCount = TmrObjPtr->TimerReload;
      /* Insert timer into timer list */
      RTC001_lInsertTimerList(TmrObjPtr->TimerID);
      /* Call timer callback function */
      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);
    }
    else
    {
      break;
    }
    /* Get first item of timer list */
      TmrObjPtr = RTC001_TimerList;	                      
  }
}

/*
 *  Event Handler 
 */

static void RTC001_SecondsEvent_Handler(uint32_t CbArg)
{ 
  /* <<<DD_RTC001_PRIV_API_4>>> */
  RTC001_TimerObject* TmrObjPtr;

  TmrObjPtr = RTC001_TimerList;
  /* <<<DD_RTC001_PRIV _API_4>>> */
  do
  {
    if(TmrObjPtr == NULL)
    {
      break;
    }
    else
    {
      if(TmrObjPtr->TimerCount >= 1)
      {
        TmrObjPtr->TimerCount--;
      }
      else
      {
        RTC001_lTimerHandler();
      }
    }
  }while(0);
}
<% } else {
 }%>

/*
 *  Initialization function which initializes the App internal data
 *  structures to default values. 
 */ 

static void  RTC001_lInit(const RTC001_HandleType* Handle)
{
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_1>>> */
<% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>					   
  /* Initialize the header of the list */
  RTC001_TimerList     = NULL; 
  /*   Initialize timer tracker  */
  RTC001_TimerTracker = 0;
<% } else {
 }%>
  SCU_INTERRUPT->SRCLR &= (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \
  								SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  								SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
  
  /* Enable alarm and periodic timer interrupts in SCU */
  SCU_INTERRUPT->SRMSK |= (((1U << SCU_INTERRUPT_SRMSK_PI_Pos) & SCU_INTERRUPT_SRMSK_PI_Msk) | \
    							((1U << SCU_INTERRUPT_SRMSK_AI_Pos) & SCU_INTERRUPT_SRMSK_AI_Msk));
  
  if (Handle->RTCInitOnce != 1 || (((RTC->CTR & RTC_CTR_ENB_Msk) >> RTC_CTR_ENB_Pos) == 0 )) 
   {
     /* RTC disabled to set the time */
     RTC001_Disable();  
     /* Calendar time and date set in RTC registers */
     RTC001_Clock_SetTime(&timeptr1);
   }   
    <%if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/enb") == 1) { %>  
    /* The RTC module is enabled */
	RTC->CTR |= ((uint32_t)(RTC_CTR_ENB_Msk)); 
	/* Wait for SCU register updation */
    while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
    /* Clear the update indication field in SCU register */
    SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos);
	<% }  else {
     }%>
    <%if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/tae") == 1) { %>  
   
	RTC->CTR |= ((uint32_t)(RTC_CTR_TAE_Msk));
	/* Wait for SCU register updation */
    while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
    /* Clear the update indication field in SCU register */
    SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos);
    
    /* Enables the Alarm interrupt and seconds comparison is set */
    RTC->MSKSR |=(((uint32_t)(1 << RTC_MSKSR_MAI_Pos)) & RTC_MSKSR_MAI_Msk);
    RTC->CTR |=((uint32_t)(RTC_CTR_ESEC_Msk));
    /* Wait for SCU register updation */
    while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
    /* Clear the update indication field in SCU register */
    SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos);
	<% }  else {
     }%>
     
	 <%if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/esec") == 1) { %>  
	RTC->CTR |=((uint32_t)(RTC_CTR_ESEC_Msk));
	/* Wait for SCU register updation */
    while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
    /* Clear the update indication field in SCU register */
    SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos);
	<% }  else {
     }%>
	<% if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/emic") ==1) {%>
	RTC->CTR |=((uint32_t)(RTC_CTR_EMIC_Msk));  
	/* Wait for SCU register updation */
	while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
    /* Clear the update indication field in SCU register */
    SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos);
	<% } else {
     }%>
	<% if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/ehoc") ==1) {%>
	RTC->CTR |=((uint32_t)(RTC_CTR_EHOC_Msk));
	/* Wait for SCU register updation */ 
	while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
    /* Clear the update indication field in SCU register */
    SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos); 
	<% } else {
     }%>
	<% if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/edac") ==1) {%>
	RTC->CTR |=((uint32_t)(RTC_CTR_EDAC_Msk));
	/* Wait for SCU register updation */
	while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
    /* Clear the update indication field in SCU register */
    SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos); 
	<% } else {
     }%>
	<% if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/edawec") ==1) {%>
	RTC->CTR |=((uint32_t)(RTC_CTR_EDAWEC_Msk)); 
	/* Wait for SCU register updation */
	while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
    /* Clear the update indication field in SCU register */
    SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos);
	<% } else {
     }%>
	<% if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/emoc") ==1) {%>
	RTC->CTR |=((uint32_t)(RTC_CTR_EMOC_Msk)); 
	/* Wait for SCU register updation */
	while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
    /* Clear the update indication field in SCU register */
    SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos);
	<% } else {%>
    <% }%>
	<% if (app.getIntegerValue(AppBaseuri + "/rtc/ctr/eyec") ==1) {%>
	RTC->CTR |=((uint32_t)(RTC_CTR_EYEC_Msk)); 
	/* Wait for SCU register updation */
	while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
    /* Clear the update indication field in SCU register */
    SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos);
	<% } else {
     }%>
	RTC->CTR |=((uint32_t)((Handle->DividerValue << RTC_CTR_DIV_Pos) & RTC_CTR_DIV_Msk));	
    /* Wait for SCU register updation */
    while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
    /* Clear the update indication field in SCU register */
    SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos);
    <% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>					     
	/* Enable seconds when Software timer is enabled */
  if(Handle->SoftwareTimerSel == SOFTWARE_TIMER_ENABLE)
  {
	  RTC->MSKSR |= ((((uint32_t)(1 << RTC_MSKSR_MPSE_Pos)) & RTC_MSKSR_MPSE_Msk));
	  NVIC_SCU001_RegisterCallback(NVIC_SCU001_PI,RTC001_SecondsEvent_Handler,0);
  }
  else
  {
	    <% } else {
	     }%> 
    <% if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpse") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {%>					
	/* Enable the seconds interrupt */
	RTC->MSKSR |= (((uint32_t)(1 << RTC_MSKSR_MPSE_Pos)) & RTC_MSKSR_MPSE_Msk);
	<% } else {
     }%>
	<% if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpmi") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {%>
	/* Enable the minutes interrupt */
	RTC->MSKSR |=(((uint32_t)(1 << RTC_MSKSR_MPMI_Pos)) & RTC_MSKSR_MPMI_Msk);
	<% } else {%>
    <% }%>
	<% if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpho") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {%>
	/* Enable the hours interrupt */
	RTC->MSKSR |=(((uint32_t)(1 << RTC_MSKSR_MPHO_Pos)) & RTC_MSKSR_MPHO_Msk);
	<% } else {
    }%>
	<% if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpda") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {%>
	/* Enable the days interrupt */
	RTC->MSKSR |=(((uint32_t)(1 << RTC_MSKSR_MPDA_Pos)) & RTC_MSKSR_MPDA_Msk);
	<% } else {
     }%> 
	<% if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpmo") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {%>
	/* Enable the months interrupt */
	RTC->MSKSR |=(((uint32_t)(1 << RTC_MSKSR_MPMO_Pos)) & RTC_MSKSR_MPMO_Msk);
	<% } else {
     }%>
	<% if ((app.getIntegerValue(AppBaseuri + "/rtc/msksr/mpye") ==1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1)) {%>
	/* Enable the years interrupt */
	RTC->MSKSR |=(((uint32_t)(1 << RTC_MSKSR_MPYE_Pos)) & RTC_MSKSR_MPYE_Msk);
	<% } else {
   }%> 
   
  <%String EventHandlerTimer = app.getStringValue(AppBaseuri +"/RTC001_srwTimerUserFunction");
  if((EventHandlerTimer != null) && (EventHandlerTimer != "")) %>
  <% { %>
    <% if (app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") != 1) %>
    <% { %>
    /* Register User defined Event Handler for Timer function */  
    NVIC_SCU001_RegisterCallback(NVIC_SCU001_PI,<%=EventHandlerTimer%>,0);
    <% } %>
  <% } %>
  <% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>
  }
  <% } else {
   }%>
  <%String EventHandlerAlarm = app.getStringValue(AppBaseuri +"/RTC001_srwAlarmUserFunction");
  if((EventHandlerAlarm != null) && (EventHandlerAlarm != "")) %>
  <% { %>
    <% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwTimerAlarm/0") == 1) && (app.getIntegerValue(AppBaseuri + "/RTC001_erwAlarmIntrptEna/0") == 1)) %>
    <% { %>
    /* Register User defined Event Handler for Alarm function */  
    RTC001_ConfigAlarm(&RTC001_Handle,&Alarmptr1,<%=EventHandlerAlarm%>,0);
    <% } %>
  <% } %>

  FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
}


/**
 *@}
 */

/*******************************************************************************
**                      Public Function Definitions                           **
*******************************************************************************/


/** @ingroup RTC001_publicparam
 * @{
 */

/*
 *  Initialization function which initializes the App internal data
 *  structures to default values.
 */
void RTC001_Init()
{
	RTC001_lInit(&RTC001_Handle);

}

/*
 *  Deinitialization function which initializes the App internal data
 *  structures to default values. 
 */
void  RTC001_DeInit(void)
{
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_2>>> */
	
  FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
}


/*
 *  The function enables the RTC module.
 */
status_t  RTC001_Enable(void)
{
  status_t status = RTC001_ERROR;
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_3>>> */
 
  /* SCU register cleared */
  SCU_INTERRUPT->SRCLR &= (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \
  								SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  								SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
  /* RTC module enabled */
  RTC->CTR |= (RTC_CTR_ENB_Msk);
  while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
  SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos);	
  
  status = DAVEApp_SUCCESS;	
  FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
  return status;
}


/*
 *  The function disables the RTC module.
 */
 
status_t  RTC001_Disable(void)	
{
  status_t status = RTC001_ERROR;
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_4>>> */

  /* The RTC module is disabled*/
  RTC->CTR &= (~(RTC_CTR_ENB_Msk));
  while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos)));
  SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_CTR_Pos);	

  /* The time register values are reset */
  RTC->TIM1 = 0x00000000;
  RTC->TIM0 = 0x00000000;
  while(!(SCU_INTERRUPT->SRRAW & (1 << SCU_INTERRUPT_SRRAW_RTC_TIM0_Pos)));
  SCU_INTERRUPT->SRCLR = (1 << SCU_INTERRUPT_SRRAW_RTC_TIM0_Pos);
  SCU_INTERRUPT->SRCLR = (1 << SCU_INTERRUPT_SRRAW_RTC_TIM1_Pos);

  /* The Alarm register values are reset */
  RTC->ATIM1 = 0x00000000;
  RTC->ATIM0 = 0x00000000;
  while(!(SCU_INTERRUPT->SRRAW & (1 << SCU_INTERRUPT_SRRAW_RTC_ATIM0_Pos)));
  SCU_INTERRUPT->SRCLR = (1 << SCU_INTERRUPT_SRRAW_RTC_ATIM0_Pos);
  SCU_INTERRUPT->SRCLR = (1 << SCU_INTERRUPT_SRRAW_RTC_ATIM1_Pos);

  SCU_INTERRUPT->SRCLR &= (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \
  								SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  								SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
  								
  status = DAVEApp_SUCCESS;
  FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
  return status;
}


/*
 *  The function gets RTC flag status.
 */	
status_t  RTC001_GetFlagStatus(RTC001_FlagType Flag)
{
  status_t status = RTC001_RESET;
  uint32_t TempValue = 0U;
  /* <<<DD_RTC001_API_6>>> */
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
	do
	{
  		if(Flag <= DAYS_FLAG)
		{
		    /* Flag value captured */
			TempValue = RTC->STSSR;
			TempValue  &= (0x1U << Flag);
		}
		else if(Flag <= YEARS_FLAG)
		{
		    /* Flag value captured */
			TempValue = RTC->STSSR;
			TempValue  &= (0x1U << ( (uint8_t)Flag + 0x01U));
		}
		else
		{
		 	/* Flag value captured */
			TempValue = RTC->STSSR;
			TempValue  &= (0x1U <<(((uint8_t)Flag) + 0x02U ));
		} 
  	    if(TempValue != 0U)
  	    {
  	      status = RTC001_SET;
  	    }

	}while(0);
	FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
	return status;
}


/*
 *  The function clears RTC flag status.
 */
void  RTC001_ClearFlagStatus(RTC001_FlagType Flag)
{
  /* <<<DD_RTC001_API_5>>> */
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
	do
	{
		if(Flag <= DAYS_FLAG)
		{
			/* Flag value cleared */
			RTC->CLRSR |= (0x01U << Flag);
		}
		else if(Flag <= YEARS_FLAG)
		{
			/* Flag value cleared */
			RTC->CLRSR |= (0x01U << ((uint8_t) Flag + 0x01U));
		}
		else
		{
			/* Flag value cleared */
			RTC->CLRSR |= (0x01U << ((uint8_t) (Flag + 0x02U )));
		} 

	}while(0);
	FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
}

<% if ((app.getIntegerValue(AppBaseuri + "/RTC001_erwSoftwareTimer/0") == 1)) {%>					
/*
 *  Interface for creating a new software Timer instance.
 */
handle_t RTC001_CreateTimer
(
  uint32_t Period,
  RTC001_TimerType TimerType, 
  RTC001_TimerCallBackPtr TimerCallBack, 
  void  * pCallBackArgPtr
)
{
  uint8_t TimerID = 0;
  uint8_t Count = 0;
  /* <<<DD_RTC001_API_7>>> */
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
  do
  {
    /* Check for input parameter */
    if((TimerType != RTC001_ONE_SHOT) && (TimerType != RTC001_PERIODIC))
    {
      ERROR(GID_RTC001,RTC001_INVALID_HANDLE, 0, NULL);
      break;	
    }
    if(TimerCallBack == NULL)
    {
      ERROR(GID_RTC001,RTC001_INVALID_HANDLE, 0, NULL);
      break;
    }
    for(Count = 0; Count < RTC001_CFG_MAX_TMR; Count++)
    {
      /* Check for free timer ID */
      if((RTC001_TimerTracker & ((uint32_t)1U << Count)) == 0) 
      {
        /* If yes,assign ID to this timer      */
        RTC001_TimerTracker |= ((uint32_t)1U << Count);   
         /* Initialize timer as per input values */
        RTC001_TimerTbl[Count].TimerID     = Count;     
        RTC001_TimerTbl[Count].TimerType   = TimerType;	
        RTC001_TimerTbl[Count].TimerState  = TIMER_STATE_STOPPED;
        RTC001_TimerTbl[Count].TimerCount    = Period;
        RTC001_TimerTbl[Count].TimerReload	= Period;
        RTC001_TimerTbl[Count].TimerCallBack = TimerCallBack;
        RTC001_TimerTbl[Count].ParamToCallBack = pCallBackArgPtr;
        RTC001_TimerTbl[Count].TimerPrev   = NULL;
        RTC001_TimerTbl[Count].TimerNext   = NULL;
        TimerID = Count + 1;
        break;               
      }
    }  
  }while(0);
  FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
  return TimerID;                
}  

/*
 *  Interface to start the software timer .
 */
status_t RTC001_StartTimer(handle_t  Handle) 
{
  uint32_t Error = RTC001_ERROR;
  /* <<<DD_RTC001_API_9>>> */
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
  do
  {
    /* Check validity of parameter        */
    if(Handle > RTC001_CFG_MAX_TMR)
    {
        Error = RTC001_INVALID_HANDLE;
        ERROR(GID_RTC001,Error, 0, NULL);
        break;
    }
    if( (RTC001_TimerTracker & ((uint32_t)1U << (Handle - 1))) == 0)
    {
        Error = RTC001_INVALID_HANDLE;
        ERROR(GID_RTC001,Error, 0, NULL);
        break;
    }
    /* Check if timer is running */    
    if(RTC001_TimerTbl[(Handle - 1)].TimerState != TIMER_STATE_RUNNING)   
    {
      /* set timer status as TIMER_STATE_RUNNING */
      RTC001_TimerTbl[(Handle - 1)].TimerState = TIMER_STATE_RUNNING;
      /* Insert this timer into timer list  */
      RTC001_lInsertTimerList((Handle - 1));     
    }       
    Error = DAVEApp_SUCCESS;                    
  }while(0);
  FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
  return Error;
}


/*
 *  Interface to stop the software timer.
 */
status_t RTC001_StopTimer(handle_t Handle) 
{
  uint32_t Error = RTC001_ERROR;
  /* <<<DD_RTC001_API_10>>> */
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
  do
  {
    /* Check validity of parameter        */
    if(Handle > RTC001_CFG_MAX_TMR)
    {
      Error = RTC001_INVALID_HANDLE;
      ERROR(GID_RTC001,Error, 0, NULL);
      break;
    }
    if( (RTC001_TimerTracker & ((uint32_t)1U << (Handle - 1))) == 0)
    {
      Error = RTC001_INVALID_HANDLE;
      ERROR(GID_RTC001,Error, 0, NULL);
      break;
    }
    /* Check whether Timer is in Stop state */
    if(RTC001_TimerTbl[(Handle - 1)].TimerState != TIMER_STATE_STOPPED)
    {
      /* remove Timer from node list */
      RTC001_lRemoveTimerList((Handle - 1));
  
      /* Set timer status as TIMER_STATE_STOPPED  */
      RTC001_TimerTbl[(Handle - 1)].TimerState = TIMER_STATE_STOPPED;
    }	
    Error = DAVEApp_SUCCESS;              
  }while(0);
  FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
  return Error;
}

/*
 *  Function to delete the Timer instance.
 */
status_t RTC001_DeleteTimer(handle_t Handle) 
{
  uint32_t Error = RTC001_ERROR;
  /* <<<DD_RTC001_API_8>>> */
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
  do
  {
    /* Check validity of parameter        */
    if(Handle > RTC001_CFG_MAX_TMR)
    {
      Error = RTC001_INVALID_HANDLE;
      ERROR(GID_RTC001,Error, 0, NULL);
      break;
    }
    if( (RTC001_TimerTracker & ((uint32_t)1U << (Handle - 1))) == 0)
    {
      Error = RTC001_INVALID_HANDLE;
      ERROR(GID_RTC001,Error, 0, NULL);
      break;
    }
    /* Check if timer is running */
    if(RTC001_TimerTbl[(Handle - 1)].TimerState == TIMER_STATE_RUNNING) 
    {
        /* Yes,remove this timer from timer list*/
        RTC001_lRemoveTimerList((Handle - 1));         
    }
    /* Release resource that this timer hold*/
    RTC001_TimerTracker &=~((uint32_t)1U << (Handle - 1));     
    Error = DAVEApp_SUCCESS;           
  }while(0);
  FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
  return Error;
}
<% } else {
 }%>

/*
 *  Interface to config the alarm.
 */

status_t RTC001_ConfigAlarm (const RTC001_HandleType* Handle, RTC001_TimeHandle* timeptr, AlarmCallBackPtr CallBack,uint32_t CbArg)
{
  uint16_t m1 = 0,y1 = 0,d1 = 0,t1 = 0;
  status_t status = RTC001_ERROR;
  /* <<<DD_RTC001_API_11>>> */
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
  do
  {
   /* <<<DD_RTC001 _API_4>>> */
  /* Clearing SRCLR register */
  SCU_INTERRUPT->SRCLR &= (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \
  								SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  								SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
  	/* Check null callback condition */							
    if(CallBack == NULL)
    {
      status = RTC001_INVALID_HANDLE;
      ERROR(GID_RTC001,RTC001_INVALID_HANDLE, 0, NULL);
      break;
    }
  	else
  	{							
	  NVIC_SCU001_RegisterCallback(NVIC_SCU001_AI,CallBack,CbArg);
	}
	
  /*   Write values into ATIM0 and ATIM1 registers  */

    m1 = timeptr->Month;
    y1 = timeptr->Year;
    d1 = timeptr->Days;
    /* Check whether the date entered is valid */
    if (RTC001_ldatevalid(m1,d1,y1))
    { 

	  t1 = ((uint32_t)(RTC001_lweekday(m1,d1,y1)));
	  if(t1<6)
	  {
	    t1=(t1+1);
	  }
	  else if(t1==6)
	  {
	    t1=0;
	  }

      RTC->ATIM0 = (((timeptr->Sec) & RTC_ATIM0_ASE_Msk) | ((((uint32_t)timeptr->Min) << RTC_ATIM0_AMI_Pos) & RTC_ATIM0_AMI_Msk) | \
      ((((uint32_t)timeptr->Hours) << RTC_ATIM0_AHO_Pos) & RTC_ATIM0_AHO_Msk) | \
      ((((uint32_t)((timeptr->Days)-1)) << RTC_ATIM0_ADA_Pos) & RTC_ATIM0_ADA_Msk));

      RTC->ATIM1 = ((t1) | (((uint32_t)((timeptr->Month)-1)) << RTC_ATIM1_AMO_Pos)|\
      (((uint32_t)timeptr->Year) << RTC_ATIM1_AYE_Pos));

	  while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_ATIM0_Pos)));
      SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_ATIM0_Pos);   
      SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_ATIM1_Pos);


    }  
    else
    {
      status = RTC001_INVALID_HANDLE;
      ERROR(GID_RTC001,status, 0, NULL);
      break;
    }
    status = DAVEApp_SUCCESS;   
  }while(0);
  FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
  return status;
}
	

/*
 *  Interface to get the RTC time at a particular instance.
 */
 
status_t RTC001_Clock_GetTime (RTC001_TimeHandle* timeptr)
{
  status_t status = RTC001_ERROR;
  uint32_t temp0,temp1;
  temp0 = RTC->TIM0;
  temp1 = RTC->TIM1;
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_12>>> */
  /* Initialize the header of the list */

  /*   Read values from TIM0 and TIM1 registers  */

  /*   Days of Week value  */
	timeptr->DaWe = (uint8_t)(temp1 & RTC_TIM1_DAWE_Msk);
  /*   Month value  */
	timeptr->Month = (uint8_t)(((temp1 & RTC_TIM1_MO_Msk) >> RTC_TIM1_MO_Pos) + 1U);
  /*   Year value  */
	timeptr->Year = (uint32_t)((temp1 & RTC_TIM1_YE_Msk) >> RTC_TIM1_YE_Pos);

  /*   Seconds value  */
	timeptr->Sec =  (uint8_t)((temp0 & RTC_TIM0_SE_Msk));
  /*   Minutes value  */
	timeptr->Min = (uint8_t)(((temp0 & RTC_TIM0_MI_Msk) >> RTC_TIM0_MI_Pos));
  /*   Hours value  */
	timeptr->Hours = (uint8_t)(((temp0 & RTC_TIM0_HO_Msk) >> RTC_TIM0_HO_Pos));
  /*   Days value starting from the 1st day of the month */
	timeptr->Days = (uint8_t)(((temp0 & RTC_TIM0_DA_Msk) >> RTC_TIM0_DA_Pos) + 1U);
	status = DAVEApp_SUCCESS;
  FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
  return status;
}


/*
 *  This function is to set the time.
 */
status_t RTC001_Clock_SetTime(RTC001_TimeHandle* timeptr)
{
  uint16_t m = 0,y =0,d = 0,t = 0;
  status_t status = RTC001_ERROR;
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_13>>> */
  
  /*   Write values into TIM0 and TIM1 registers  */

  SCU_INTERRUPT->SRCLR &= (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \
  								SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  								SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
 
  /*   Days of Week value  */
  m = timeptr->Month;
  y = timeptr->Year;
  d = timeptr->Days;
  
  do
  {    
    if (RTC001_ldatevalid(m,d,y))  
    { 
	  t = ((uint32_t)(RTC001_lweekday(m,d,y)));
	  if(t<6)
	  {
	    t=(t+1);
	  }
	  else if(t==6)
	  {
	    t=0;
	  }
      RTC->TIM1 = ((t) | (((uint32_t)((timeptr->Month)-1)) << 8U)|\
      (((uint32_t)timeptr->Year) << 16U));

      RTC->TIM0 = ((timeptr->Sec) | (((uint32_t)timeptr->Min) << 8U) | \
      (((uint32_t)timeptr->Hours) << 16U) | \
      (((uint32_t)((timeptr->Days)-1)) << 24U));

      while(!(SCU_INTERRUPT->SRRAW & (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_TIM0_Pos)));
      SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_TIM0_Pos);   
      SCU_INTERRUPT->SRCLR = (RTC001_UPDATE_COMPLETED << SCU_INTERRUPT_SRRAW_RTC_TIM1_Pos);

    }  
    else
    {
      status = RTC001_INVALID_HANDLE;
      ERROR(GID_RTC001,status, 0, NULL);
      break;
    }
   
  }while(0);
  status = DAVEApp_SUCCESS;
  FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
  return status;
}


/*
 *  This function is to get the time in seconds calculated from Epoc time.
 */

status_t RTC001_Time(time_t* time)
{
  uint8_t TimeMonthVar=0,TimeMonth1=0,TimeMonth2=0,TimeDay1=0,TimeDay2=0,TimeHour=0,TimeMinute=0,TimeSecond=0;
  uint32_t TimeMonthCalc1=0,TimeYear1=0,TimeYear2=0,TimeLpVar=0;
  uint32_t TimeYear3=0,TimeMonth3=0,TimeDay3=0,TimeHour2=0,TimeMinute2=0;
  uint8_t Count = 0U;
  uint32_t Temp_Value1 =0,Temp_Value2=0;
  time_t Time =0;
  status_t ReturnStatus;
  
  FUNCTION_ENTRY(GID_RTC001,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_15>>> */
  do
  {
    if((RTC->CTR & (RTC_CTR_ENB_Msk)) == 0)
    {
      ReturnStatus = RTC001_ERROR;
      break;
    }
    if(time == NULL)
    {
      ReturnStatus = RTC001_ERROR;
      break;
    }

    /*   Read values from TIM0 and TIM1 registers  */
    TimeYear1 = ((uint32_t)((RTC->TIM1 & RTC_TIM1_YE_Msk) >> 16U));
    TimeMonth1 = 	((uint8_t)(((RTC->TIM1 & RTC_TIM1_MO_Msk) >> 8U) + 1U));
    TimeDay1 = ((uint8_t)(((RTC->TIM0 & RTC_TIM0_DA_Msk) >> 24U) + 1U));
    TimeHour = ((uint8_t)(((RTC->TIM0 & RTC_TIM0_HO_Msk) >> 16U)));
    TimeMinute = ((uint8_t)(((RTC->TIM0 & RTC_TIM0_MI_Msk) >> 8U)));
    TimeSecond = ((uint8_t)((RTC->TIM0 & RTC_TIM0_SE_Msk)));
  
	/* Count the number of days to be adjusted for leap years, start from previous year */
    /*TimeLpYear = TimeYear1;*/
    for (TimeLpVar=(TimeYear1-1); TimeLpVar>= 1970U; TimeLpVar--)
    {
      if((((TimeLpVar) % 400) ==0) || ((((TimeLpVar) % 100) != 0) && (((TimeLpVar) %4) == 0)))
      {
        Count++;
      }
    }
    /*if current year is leap year add 1 only if March or later*/
    if((((TimeYear1) % 400) ==0) || ((((TimeYear1) % 100) != 0) && (((TimeYear1) %4) == 0)))
    {
	  if(TimeMonth1 > 2)
	  {
		Count++;
	  }
    }

    Temp_Value1 = (Count * 0x18U * 0x3CU * 0x3CU);

	/* Difference Calculation */
    TimeYear2 = (TimeYear1 - (0x7B2U));
    TimeMonth2 = (TimeMonth1 - (1U));
    TimeDay2 = (TimeDay1 - (1U));
	
    /* Calculation of seconds for ordinary year */
    TimeYear3 = (TimeYear2 * 0x16DU * 0x18U * 0x3CU * 0x3CU);
  /* Calculation of seconds for ordinary month */
    for (TimeMonthVar=TimeMonth2;TimeMonthVar>=1U;TimeMonthVar--)
    {
      if((TimeMonthVar <= 7) && ((TimeMonthVar % 2) == 1))
      {
        TimeMonthCalc1 = (1U * 0x1FU * 0x18U * 0x3CU * 0x3CU);		/* 31*/
	  }
	  if((TimeMonthVar <= 7) && ((TimeMonthVar % 2) == 0))
	  {
	    if(TimeMonthVar == 2)
	    {
	      TimeMonthCalc1 = (1U * 0x1CU * 0x18U * 0x3CU * 0x3CU);	 /* 28*/
	    }
	    else
	    {
	      TimeMonthCalc1 = (1U * 0x1EU * 0x18U * 0x3CU * 0x3CU);	   /* 30*/
	    }
	  }
	  if((TimeMonthVar > 7) && ((TimeMonthVar % 2) == 0))
	  {
        TimeMonthCalc1 = (1U * 0x1EU * 0x18U * 0x3CU * 0x3CU);		 /* 30*/
	  }
	  if((TimeMonthVar > 7) && ((TimeMonthVar % 2) == 1))
	  {
	    TimeMonthCalc1 = (1U * 0x1FU * 0x18U * 0x3CU * 0x3CU);		 /* 31*/
	  }
      TimeMonth3 = TimeMonth3 + TimeMonthCalc1;
    }
	/* Calculation of seconds for ordinary day */
    TimeDay3 = (TimeDay2 * 0x18U * 0x3CU * 0x3CU);
	/* Calculation of seconds for ordinary hour */
    TimeHour2 = (TimeHour * 0x3CU * 0x3CU);
	/* Calculation of seconds for ordinary minute */
    TimeMinute2 = (TimeMinute * 0x3CU);
	/* Calculation of seconds for ordinary second */
	
    Temp_Value2 = (TimeYear3 + TimeMonth3 + TimeDay3 + TimeHour2 + TimeMinute2 + TimeSecond);
    Time = Temp_Value1 + Temp_Value2;
    *time = Time;
    ReturnStatus = DAVEApp_SUCCESS;

  }
  while(0);
  FUNCTION_EXIT(GID_RTC001,RTC001_FUNCTION_EXIT);
  return ReturnStatus;
}
/* return 1 if date is valid, 0 otherwise.	*/
static uint32_t RTC001_ldatevalid(uint16_t m,uint16_t d,uint16_t y)
{
  uint8_t valid;
  do{
  if ((m == 0) || (m > 12) )
  {
	valid = 0;
    break;
  }
  if (m != 2)
  {
    if ( (d == 0) || (d > 31) )
    {
      valid = 0;
	  break;
    }
    if ( (m == 4) || (m == 6) || (m == 9) || (m == 11) )
    {
      if ( d > 30 )
      {
        valid = 0;
		break;
      }
      else
      {
		valid = 1;
        break;
      }
    }
  }
  else
  {
    if ( d > 29 )
    {
      valid = 0;
      break;
    }
    if ( d < 29 )
    {
      valid = 1;
      break;
    }
    if ((((y) % 400U) ==0) || ((((y) % 100U) != 0) && (((y) %4U) == 0)))
    {
      valid = 1;
      break;
    }
    else 
    {
      valid = 0;
      break;
    }
  }
  valid = 1;
  }while(0);
  return valid;
}

/* given month, day, year, returns day of week, eg. Monday = 0 etc.
 tested for 1901 to 2099 (seems to work from 1800 on too)*/ 

static uint32_t RTC001_lweekday(uint16_t m,uint16_t d,uint16_t y)
{
    uint16_t vx, tx, ix, feb;
    uint8_t vx_list[] = {0, 20, 0, 16, 24, 20, 0, 24, 4, 12, 8, 16, 12,};

    vx = vx_list[m];
    if(y > 1900)
    {
      y = y - 1900;
    }
    feb = m  > 2 ;
	/* take care of February */
    ix = ((y - 21) % 28) + vx + feb;
	/* take care of leap year */
    tx = ((ix + (ix / 4)) % 7) + d;
    return (tx % 7);
}

/**
 *@}
 */

/*CODE_BLOCK_END*/
